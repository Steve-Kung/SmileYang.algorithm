20191016
为什么Mysql索引要用B+树？
hashMap的时间复杂度是O1，B+树是logN;
but文件系统和数据库的索引都是存在硬盘上的，如果数据量大的话不能一次性加载到内存中。
场景：
如果只查一个数据Hash更快，因为不用考虑数据太多没法一次性从磁盘加载到内存的问题。
但实际上常常不止查一个数据
比如根据Id来select多条字段然后排序，用B树的话就需要跨层访问，而B+树里数据都在叶子结点上，不用跨层。
而且索引有序，又有链表相连就比Hash快多了
 2019.10.22
 Unity项目的多线程使用
 why:项目中需要网络请求，IO等耗时操作
 what:
  坑：（1）当你愉快的在多线程中访问UI控件时，Duang~~~，一个错误告诉你，不能在异步线程访问UI控件。这是肯定的，跨线程访问UI控件是不安全的，理应被禁止。
        使用 生产者-消费者模式（自定义的 UnityDispatcher 提供一个 BeginInvoke 方法，并接送一个 Action；一个生产者向队列里添加需要处理的Action。
        Unity中的Update 就是一个消费者，每一帧都会执行，所以如果队列里有任务，它就执行） 的方式告诉一个在主线程上的 Dispatcher ，来控制 Unity 的组件。
         值得注意的是，Queue不是线程安全的，所以需要锁，我使用了 Interlocked.Exchange，好处是它以原子的操作来执行并且还不会阻塞线程，因为主线程本身任务繁重，所以我不推荐使用lock。
    （2）延时严重---进行共享数据的处理
        开始直接用unity中的 System.Threading.Thread 类直接创建。
        A，B两个线程同一时刻处理一个变量，它最终的值到底是什么。
        所以一般需要使用lock，但C#提供了另一个关键字 volatile，告诉CPU不读缓存直接把最新的值返回。
        所以_shouldStop被volatile修饰。
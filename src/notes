20191016
为什么Mysql索引要用B+树？
hashMap的时间复杂度是O1，B+树是logN;
but文件系统和数据库的索引都是存在硬盘上的，如果数据量大的话不能一次性加载到内存中。
场景：
如果只查一个数据Hash更快，因为不用考虑数据太多没法一次性从磁盘加载到内存的问题。
但实际上常常不止查一个数据
比如根据Id来select多条字段然后排序，用B树的话就需要跨层访问，而B+树里数据都在叶子结点上，不用跨层。
而且索引有序，又有链表相连就比Hash快多了
 2019.10.22
 Unity项目的多线程使用
 why:项目中需要网络请求，IO等耗时操作
 what:
  坑：（1）当你愉快的在多线程中访问UI控件时，Duang~~~，一个错误告诉你，不能在异步线程访问UI控件。这是肯定的，跨线程访问UI控件是不安全的，理应被禁止。
        使用 生产者-消费者模式（自定义的 UnityDispatcher 提供一个 BeginInvoke 方法，并接送一个 Action；一个生产者向队列里添加需要处理的Action。
        Unity中的Update 就是一个消费者，每一帧都会执行，所以如果队列里有任务，它就执行） 的方式告诉一个在主线程上的 Dispatcher ，来控制 Unity 的组件。
         值得注意的是，Queue不是线程安全的，所以需要锁，我使用了 Interlocked.Exchange，好处是它以原子的操作来执行并且还不会阻塞线程，因为主线程本身任务繁重，所以我不推荐使用lock。
    （2）延时严重---进行共享数据的处理
        开始直接用unity中的 System.Threading.Thread 类直接创建。
        A，B两个线程同一时刻处理一个变量，它最终的值到底是什么。
        所以一般需要使用lock，但C#提供了另一个关键字 volatile，告诉CPU不读缓存直接把最新的值返回。
        所以_shouldStop被volatile修饰。

        补充：譬如unmanaged数据类型可以使用引擎自带的Memory Allocator进行分配，每次new的时候都要想清楚自己这个new是否可以复用，是否会像黄河的河床一样越埋越高，隐患越来越大，最终造成“决堤”，带来不可挽回的毁灭性的损失。如果是UI带来的GC压力，可以考虑魔改UI层源码，通过提交一个字符串的引用而不是强硬的深复制，一般正确的做法是直接调用UnityEngine.Scripting.GarbageCollector关掉自动GC，并在需要的时候手动调用GC，如果在游戏运行过程中内存直接炸掉，这就要准备分锅了，看谁写的代码在不断的制造内存垃圾，引发内存泄露。
2019.10.24
Json文件如何转C语言？


2019/11/5
写了一白天的codesys和一晚上的java小细节,源码不好读

2019/11/13-15刷了6道贪心算法题
通过MoonCake题学到了1.BufferedRead；2.内部类实现Comparable接口作为某对象参数的封装体；3.通过重写Comparable的compareTo方法自定义sort排序；4.贪心算法
通过AssignCookie题巩固了贪心算法，学到了数组排序Array.sort()/
通过isSubsequence题巩固了贪心算法，发现答案直接判断返回很有技巧